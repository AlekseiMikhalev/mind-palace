{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This is my personal Mind Palace, where I collect knowledge from my learning journey. Every time I read some tech book, documentation, science article, or \"how to\" recipe, I make a summary in the respective section. After I watched a course or project I make a summary too. I took this approach to solve one simple problem - remember what I've read or learnt and be able to apply the knowledge in my life. Mind Palace Structure: Mind Palace consist of the following nested categories: Knowledge section (the widest knowledge group) Knowledge concept (category of the group related to the particular technology) Code snippets (examples of how to implement the particular knowledge concept) Code snippets also include the detailed explanation of each line of code. That helps me to understand how the code works and remember it later during the implementation. The knowledge base in this digital Mind Palace is related to various software development areas. My learning path is focused on expanding my knowledge step-by-step and eventually building a solid base for developing robust complex systems. Therefore, it includes knowledge from frontend and backend development, machine learning, data science, databases, software architecture, etc. Couple of words about me I am a self-taught software developer. I started my programming journey by heart. In my childhood I wanted to be a programmer. I took some gadgets (whether it was my grandfather's watch or music player from the town dump), disassemble them and tried to assemble again. I was extremely interested to understand how they work. But something went wrong and I became a lawyer. My lawyer career includes eight years in international law firms and venture funds as a corporate lawyer. Spending long hours on drafting documents, doing due diligence or revising prospectuses for capital market deals, I realised that it's not what I want to do for life. It is just not my passion. And in my spare time I started to learn programing. Step-by-step I switched into software engineering and left my lawyer career behind. That was, and actually still very hard... But you know what? I am happy! It gives me energy and meaningful start every day. And I won't give up Comments, recommendation and revisions I would be happy if you give me any useful comments, recommendation or point out on my mistakes or code errors.","title":"Introduction"},{"location":"#introduction","text":"This is my personal Mind Palace, where I collect knowledge from my learning journey. Every time I read some tech book, documentation, science article, or \"how to\" recipe, I make a summary in the respective section. After I watched a course or project I make a summary too. I took this approach to solve one simple problem - remember what I've read or learnt and be able to apply the knowledge in my life.","title":"Introduction"},{"location":"#mind-palace-structure","text":"Mind Palace consist of the following nested categories: Knowledge section (the widest knowledge group) Knowledge concept (category of the group related to the particular technology) Code snippets (examples of how to implement the particular knowledge concept) Code snippets also include the detailed explanation of each line of code. That helps me to understand how the code works and remember it later during the implementation. The knowledge base in this digital Mind Palace is related to various software development areas. My learning path is focused on expanding my knowledge step-by-step and eventually building a solid base for developing robust complex systems. Therefore, it includes knowledge from frontend and backend development, machine learning, data science, databases, software architecture, etc.","title":"Mind Palace Structure:"},{"location":"#couple-of-words-about-me","text":"I am a self-taught software developer. I started my programming journey by heart. In my childhood I wanted to be a programmer. I took some gadgets (whether it was my grandfather's watch or music player from the town dump), disassemble them and tried to assemble again. I was extremely interested to understand how they work. But something went wrong and I became a lawyer. My lawyer career includes eight years in international law firms and venture funds as a corporate lawyer. Spending long hours on drafting documents, doing due diligence or revising prospectuses for capital market deals, I realised that it's not what I want to do for life. It is just not my passion. And in my spare time I started to learn programing. Step-by-step I switched into software engineering and left my lawyer career behind. That was, and actually still very hard... But you know what? I am happy! It gives me energy and meaningful start every day. And I won't give up","title":"Couple of words about me"},{"location":"#comments-recommendation-and-revisions","text":"I would be happy if you give me any useful comments, recommendation or point out on my mistakes or code errors.","title":"Comments, recommendation and revisions"},{"location":"backend/","text":"","title":"Backend"},{"location":"frontend/","text":"","title":"Frontend"},{"location":"machine_learning/","text":"","title":"Machine Learning"},{"location":"machine_learning/nlp/","text":"Natural Language Processing Sample Use Cases Information search Information retrieval","title":"Natural Language Processing"},{"location":"machine_learning/nlp/#natural-language-processing","text":"","title":"Natural Language Processing"},{"location":"machine_learning/nlp/#sample-use-cases","text":"Information search Information retrieval","title":"Sample Use Cases"},{"location":"projects/","text":"","title":"Projects"},{"location":"projects/age_classification/","text":"Summary The aim of this project is to make a research and find a solution for age classification based on face recognition. Based on face images collected from the camera, the ML model should classify faces into one of the specific age ranges. Sources Review The following articles were analysed: Gupta, S.K., Nain, N. Review: Single attribute and multi attribute facial gender and age estimation. Multimed Tools Appl (2022) ELKarazle, K.; Raman, V.; Then, P. Facial Age Estimation Using Machine Learning Techniques: An Overview. Big Data Cogn. Comput. 2022, 6, 128. Research Results The result of facial age estimation can be either age range (classification problem) or exact age value (regression problem). Main challenges in building efficient age prediction systems are: Real-life factors of face imaging such as resolution , sharpness , illumination , expression , occlusion , profile , frontal view , constraint environment , unconstraint environment , longitudinal , race , hair , scale , etc. Datasets creation Existing datasets usually divided into the following types: controlled (prepared in controlled environment with limited variability). Examples: FG-NET , MORPH , VADANA uncontrolled (prepared in real-life with different variability). Examples: LFW , IMDB-WIKI , ChaLearn Looking at People (LAP) , Specs on Face (SoF) , MSU LFW+ , YGA Steps for dataset creation: Image of faces collection Pre-processing cropping rotating aligning augmenting Evaluation metrics used: accuracy : \\((true positive + true negative)/(total test samples)\\) , and Mean Absolute Error (MAE) : mean value of the absolute differences between predicted age and real age (ground truth) of test samples Steps of model building 1. Feature extraction Extract unique and distinguishable patterns related to particular age classes. That includes facial age features such as texture or edge relathioships of facial skin. Global Features - apperance based feature extraction. The whole face is considered as feature space. Local Features - geometry based feature extraction. Feature extraction from facial parts as eyebrow, nose, lips, etc. 2. Building classification or regression model Handcrafted-based approach based on combination of filters: Histogram of Oriented Gradients (HOG) or Local Binary Pattern (LBP) to extract edges and shapes from facial image Deep learning approach based on CNNs. Examples of pre-trained models used for age estimation: VGG-16, VGG-19, ResNet50, AlexNet, Xception, GoogleLeNet, MobileNetV2","title":"Age Classification"},{"location":"projects/age_classification/#summary","text":"The aim of this project is to make a research and find a solution for age classification based on face recognition. Based on face images collected from the camera, the ML model should classify faces into one of the specific age ranges.","title":"Summary"},{"location":"projects/age_classification/#sources-review","text":"The following articles were analysed: Gupta, S.K., Nain, N. Review: Single attribute and multi attribute facial gender and age estimation. Multimed Tools Appl (2022) ELKarazle, K.; Raman, V.; Then, P. Facial Age Estimation Using Machine Learning Techniques: An Overview. Big Data Cogn. Comput. 2022, 6, 128.","title":"Sources Review"},{"location":"projects/age_classification/#research-results","text":"The result of facial age estimation can be either age range (classification problem) or exact age value (regression problem). Main challenges in building efficient age prediction systems are: Real-life factors of face imaging such as resolution , sharpness , illumination , expression , occlusion , profile , frontal view , constraint environment , unconstraint environment , longitudinal , race , hair , scale , etc. Datasets creation Existing datasets usually divided into the following types: controlled (prepared in controlled environment with limited variability). Examples: FG-NET , MORPH , VADANA uncontrolled (prepared in real-life with different variability). Examples: LFW , IMDB-WIKI , ChaLearn Looking at People (LAP) , Specs on Face (SoF) , MSU LFW+ , YGA Steps for dataset creation: Image of faces collection Pre-processing cropping rotating aligning augmenting Evaluation metrics used: accuracy : \\((true positive + true negative)/(total test samples)\\) , and Mean Absolute Error (MAE) : mean value of the absolute differences between predicted age and real age (ground truth) of test samples","title":"Research Results"},{"location":"projects/age_classification/#steps-of-model-building","text":"1. Feature extraction Extract unique and distinguishable patterns related to particular age classes. That includes facial age features such as texture or edge relathioships of facial skin. Global Features - apperance based feature extraction. The whole face is considered as feature space. Local Features - geometry based feature extraction. Feature extraction from facial parts as eyebrow, nose, lips, etc. 2. Building classification or regression model Handcrafted-based approach based on combination of filters: Histogram of Oriented Gradients (HOG) or Local Binary Pattern (LBP) to extract edges and shapes from facial image Deep learning approach based on CNNs. Examples of pre-trained models used for age estimation: VGG-16, VGG-19, ResNet50, AlexNet, Xception, GoogleLeNet, MobileNetV2","title":"Steps of model building"},{"location":"projects/book_summarizer/","text":"","title":"Book Summarizer"},{"location":"software_architecture/","text":"Software Architecture This section contains knowledge about software architecture concepts, patterns, and best practices. Due to my love of Python, architectural examples are provided in Python. Sources Overview Books Software Architecture for Busy Developers YouTube Videos Architecture of modern WEB applications. Evolution from A to Z Courses Educative.io Main Concepts Architecture - set of modules and components of the system, description of how these modules and components should be developed, how they should be connected, and interfaces that specify the purpose of each module and component. Components inside modules should be tightly-coupled . Modules should be loosely-coupled . Deletion/revision of a module should be simple, and should not affect other modules significantly. Separation of concerns - different parts of a system should manage different parts of the process. Inversion of control - helps to avoid strong coupling between components of the system. It realised by wrapping components and expose specific interface. Thus, components can be connected via interface rather than their hard-coded specific implementation. Think of the following responsibilities while architecting software: Address functional and non-functional requirements Use technical standards, coding best practices and design patterns Interact with stakeholders to ensure smooth development and implementation Play an active role in the development process Proactive watching over tech trends and paradigm shifts, but do not follow them blindly Main architectural principles DRY SOLID KISS PATTERNS Architecture of WEB Application Each component of the above schema is described in the respective topic of the Backend or Frontend sections. Architectural Styles Monolith benefits: easy to develop easy to deploy (as a single package) easy to monitor The key is simplicity, as long as the application remains lightweight. challenges: adding new features and debugging becomes complicated while the app grows the code is tightly coupled, so it violates single responsibility principle lack of granular scalability availability at risk (error in one module can cause of cascade blocking of the whole app) high risk of technical debt Service Oriented Architecture (SOA) It has middle core componet - Enterprise Service Bus benefits: decouple application and services better governance, as SOA aims to provide single source of truth reusability of components technology agnostic scalability, as each service is independent challenges: lack of agility","title":"Software Architecture"},{"location":"software_architecture/#software-architecture","text":"This section contains knowledge about software architecture concepts, patterns, and best practices. Due to my love of Python, architectural examples are provided in Python.","title":"Software Architecture"},{"location":"software_architecture/#sources-overview","text":"","title":"Sources Overview"},{"location":"software_architecture/#books","text":"Software Architecture for Busy Developers","title":"Books"},{"location":"software_architecture/#youtube-videos","text":"Architecture of modern WEB applications. Evolution from A to Z","title":"YouTube Videos"},{"location":"software_architecture/#courses","text":"Educative.io","title":"Courses"},{"location":"software_architecture/#main-concepts","text":"Architecture - set of modules and components of the system, description of how these modules and components should be developed, how they should be connected, and interfaces that specify the purpose of each module and component. Components inside modules should be tightly-coupled . Modules should be loosely-coupled . Deletion/revision of a module should be simple, and should not affect other modules significantly. Separation of concerns - different parts of a system should manage different parts of the process. Inversion of control - helps to avoid strong coupling between components of the system. It realised by wrapping components and expose specific interface. Thus, components can be connected via interface rather than their hard-coded specific implementation. Think of the following responsibilities while architecting software: Address functional and non-functional requirements Use technical standards, coding best practices and design patterns Interact with stakeholders to ensure smooth development and implementation Play an active role in the development process Proactive watching over tech trends and paradigm shifts, but do not follow them blindly Main architectural principles DRY SOLID KISS PATTERNS","title":"Main Concepts"},{"location":"software_architecture/#architecture-of-web-application","text":"Each component of the above schema is described in the respective topic of the Backend or Frontend sections.","title":"Architecture of WEB Application"},{"location":"software_architecture/#architectural-styles","text":"Monolith benefits: easy to develop easy to deploy (as a single package) easy to monitor The key is simplicity, as long as the application remains lightweight. challenges: adding new features and debugging becomes complicated while the app grows the code is tightly coupled, so it violates single responsibility principle lack of granular scalability availability at risk (error in one module can cause of cascade blocking of the whole app) high risk of technical debt Service Oriented Architecture (SOA) It has middle core componet - Enterprise Service Bus benefits: decouple application and services better governance, as SOA aims to provide single source of truth reusability of components technology agnostic scalability, as each service is independent challenges: lack of agility","title":"Architectural Styles"},{"location":"software_architecture/architectural_patterns/mv_patterns/","text":"MV* Architectural Patterns Brief description of the following patterns: MVC MVVM MVP Key Ideas Split business logic of the application from interface. Business logic is the core functionality that solves specific business problem ( for example, user registration, payments, add item to the basket, blog post creation, etc.) It is an algorithm of process that we want to implement to transform data somehow in order to provide a service (solve business problem). Sometimes it is called \"use case\". Interface is the graphical interface that user interacts with. Such as forms, buttons, etc. Controller is an intermediary between the UI (View) and business logic (Model). It should be 'thin', so it should not duplicate business logic or take any part of it, only some 'light' features, such as values validation.","title":"Architectural Patterns"},{"location":"software_architecture/architectural_patterns/mv_patterns/#mv-architectural-patterns","text":"Brief description of the following patterns: MVC MVVM MVP","title":"MV* Architectural Patterns"},{"location":"software_architecture/architectural_patterns/mv_patterns/#key-ideas","text":"Split business logic of the application from interface. Business logic is the core functionality that solves specific business problem ( for example, user registration, payments, add item to the basket, blog post creation, etc.) It is an algorithm of process that we want to implement to transform data somehow in order to provide a service (solve business problem). Sometimes it is called \"use case\". Interface is the graphical interface that user interacts with. Such as forms, buttons, etc. Controller is an intermediary between the UI (View) and business logic (Model). It should be 'thin', so it should not duplicate business logic or take any part of it, only some 'light' features, such as values validation.","title":"Key Ideas"}]}